// Scans app/**/widget.ts files and generates the tool registry.
// Run: bun scripts/generate-registry.ts
import { resolve, relative } from "path";
import type { ToolWidgetMeta } from "../lib/dash/types";

const ROOT = resolve(import.meta.dir, "..");
const OUT = resolve(ROOT, "lib/dash/registry.generated.ts");

const glob = new Bun.Glob("app/**/widget.ts");
const paths = [...glob.scanSync({ cwd: ROOT, absolute: true })].sort();

interface WidgetModule {
  default: ToolWidgetMeta;
  extras?: ToolWidgetMeta[];
}

const entries: ToolWidgetMeta[] = [];
const seenIds = new Set<string>();

for (const abs of paths) {
  const mod = (await import(abs)) as WidgetModule;
  if (!mod.default?.id) {
    console.warn(`Skipping ${relative(ROOT, abs)}: no default export with id`);
    continue;
  }
  if (seenIds.has(mod.default.id)) {
    console.error(`Duplicate widget ID "${mod.default.id}" in ${relative(ROOT, abs)}`);
    process.exit(1);
  }
  seenIds.add(mod.default.id);
  entries.push(mod.default);
  // Support additional widget entries (e.g. preset variants) via named export
  if (Array.isArray(mod.extras)) {
    for (const extra of mod.extras) {
      if (!extra?.id) continue;
      if (seenIds.has(extra.id)) {
        console.error(`Duplicate widget ID "${extra.id}" in ${relative(ROOT, abs)} extras`);
        process.exit(1);
      }
      seenIds.add(extra.id);
      entries.push(extra);
    }
  }
}

entries.sort((a, b) => a.id.localeCompare(b.id));

const lines = [
  "// Auto-generated by scripts/generate-registry.ts â€” do not edit manually",
  'import type { ToolWidgetMeta } from "./types";',
  "",
  `export const TOOL_REGISTRY: ToolWidgetMeta[] = ${JSON.stringify(entries, null, 2)};`,
  "",
  "export const TOOL_MAP = new Map<string, ToolWidgetMeta>(",
  "  TOOL_REGISTRY.map((t) => [t.id, t]),",
  ");",
  "",
];

await Bun.write(OUT, lines.join("\n"));
console.log(`Wrote ${entries.length} tools to ${relative(ROOT, OUT)}`);
